// Backbone.js helper methods, models, and collections which can be used to manage complex data structures
var GuruLabs = GuruLabs || {
	Models: {},
	Collections: {},
	Views: {},
};


// Create Base64 Object
GuruLabs.Base64 = {
	_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	encode: function(data) {
		if (_.isFunction(btoa)) return btoa(data);
		return GuruLabs.Base64._encode(data);
	},
	decode: function(data) {
		if (_.isFunction(atob)) return atob(data);
		return GuruLabs.Base64._decode(data);
	},
	_encode: function(e) {
		var t="";
		var n,r,i,s,o,u,a;
		var f=0;
		e=Base64._utf8_encode(e);
		while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},
	_decode:  function(e) {
		var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},
	_utf8_encode: function(e) {
		e=e.replace(/\r\n/g,"\n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},
	_utf8_decode: function(e) {
		var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}
}

// Guru Labs API Codes
GuruLabs.api = _.extend(GuruLabs.api || {}, {
	op : 'operation',
	ops : 'operations',
	opresult: 'operation-result',
	server_response: 'server-response',
	server_status_code: 'server-http-status-code',
	status : 'status',
	error : 'error',
	details: 'details',
	message_header : 'header',
	option : 'value',
	message : 'message',
	success : 'success',
	fail : 'fail',
	canceled : 'canceled',
	init : 'initialized',
	errors: {
		error_feature_support: 'error-feature-support',
		json_parse_error : 'error-parse-JSON',
		auth_error : 'error-authorization',
		connection_error: 'error-connection',
		error_init: 'error-initialization',
	},
	object_update: 'object-update',
	object_delete: 'object-delete',
	object_type: 'object-type',
	object_data: 'object-data',
	accessurl: 'href-access',
	updateurl: 'href-update',
	createurl: 'href-create',
	downloadurl: 'href-download',
	searchurl: 'href-search',
	autocomplete_suggestions_url: 'href-autocomplete',
	attr_model_fieldname: 'model-fieldname',
	pagination: {
		header: 'X-Pagination',
		page: 'page',
		page_num_results: 'page-num-results',
		page_first: 'page-first',
		page_last: 'page-last',
		page_previous: 'page-previous',
		page_next: 'page-next',
		result_range_start: 'result-range-start',
		result_range_stop: 'result-range-stop',
		result_total: 'result-total',
		errors: { out_of_bounds: 'result-out-of-bounds' },
		signalname_default: 'fetch:paginated',
	},
	xhr_status_abort: 'abort',
	http: {
		get: 'GET',
		put: 'PUT',
		post: 'POST',
		delete: 'DELETE',
		options: 'OPTIONS',
	}
});


// Helper data structures
GuruLabs._positive = ['true', 'positive', 'yes', '1', 'yup', 'y', 't'];
GuruLabs.namespace_structure = { Models: {}, Collections: {}, Views: {} }


// Functional helper functions

GuruLabs._executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	// Determines whether to execute a function as a constructor or a normal function with the provided arguments
	if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	var self = baseCreate(sourceFunc.prototype);
	var result = sourceFunc.apply(self, args);
	if (_.isObject(result)) return result;
	return self;
};

GuruLabs.partialOnly = function(func) {
	// 	Similar to _.partial, which partially applies a function by creating a version that has arguments pre-filled,
	// 	without changing the dynamic `this` context. _ acts as a placeholder, allowing any combination
	// 	of arguments to be prefilled. partialOnly differs from _.partial, however, in that if an argument value
	// 	is not pre-filled it will be truncated. This is useful for creating binding callbacks with only a subset
	// 	of the arguments applied.
	var boundArgs = Array.prototype.slice.call(arguments, 1);
	var bound = function() {
		var position = 0, length = boundArgs.length;
		var args = Array(length);
		// Merge arguments with bound arguments (allow _ as a placeholder)
		for (var i = 0; i < length; i++) {
			args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
		}
		return GuruLabs._executeBound(func, bound, this, this, args);
	}
	return bound;
}


GuruLabs.arraySortedEquals = function(a, b) {
	// Compare the contents of arrays a and b for equality. Sorts the contents before comparison.

	return _.isArray(a) && _.isArray(b)
		&& a.length == b.length 
		&& JSON.stringify(a.sort()) == JSON.stringify(b.sort());
}


// Patch Underscore to include extended helper functions

GuruLabs._clone = _.clone;
GuruLabs._deepClone = function(obj) {
 return (!obj || (typeof obj !== 'object'))?obj :
	(_.isString(obj)) ? String.prototype.slice.call(obj):
	(_.isDate(obj)) ? new Date(obj.valueOf()):
	(_.isFunction(obj.clone)) ? obj.clone():
	(_.isArray(obj)) ? _.map(obj, function(t){return GuruLabs._deepClone(t)}):
	_.mapObject(obj, function(val, key) {return GuruLabs._deepClone(val)});
}
_.mixin({
	clone: function(obj, options) {
		// Provide a deep option to the clone function in Underscore
		options = options || {};
		_.defaults(options, { deep: false });
		if (options.deep) return GuruLabs._deepClone(obj);
		return GuruLabs._clone(obj, options);
	}
});


// Numerical helper functions

GuruLabs.fixedplace_decimal = function(ginput, options){
	// 	Return a fixed place version of the input number, rounded to the fixed number of decimal places
	//	specified by the digits option.
	
	//	@input ginput (Number): Number to be rounded
	//	@input options (options hash)
	
	//	@option decimal_places (int, default=2): Number of digits to include in the output
	
	//	@returns rounded and formatted number
	options = options || {};
	_.defaults(options, { decimal_places: 2 });
	return (Math.round(ginput * (10*options.decimal_places)) / (10*options.decimal_places)).toFixed(options.decimal_places);
}


// Helper functions

GuruLabs.preparePathArray = function(pathstr) {
	//	Translate a path string to an array
	//	@input pathstr (str in dot notation, e.g., 'prop1.prop2.prop3' or array, e.g. ['prop1', 'prop2', 'prop3']):
	//		Path to convert to array
	var patharray;
	if (_.isString(pathstr)) patharray = pathstr.split('.');
	else if (_.isArray(pathstr)) patharray = pathstr;
	else {
		throw new Error('preparePathArray: pathstr must be a string in dot notation or array');
	}
	return patharray;
}


GuruLabs.hasObjectPath = function(gobject, gobject_path) {
	// 	Check if the provided object has a property corresponding to the specified object path.
	//	The object path should be provided in dot notation (e.g., 'prop1.prop2.prop3')
	//	@input gobject (object): Object to check for the provided object path
	//	@input gobject_path (str in dot notation, e.g., 'prop1.prop2.prop3' or array, e.g. ['prop1', 'prop2', 'prop3']):
	//		Property path for which the object should be tested
	//	@returns bool: true if the path exists, false otherwise
	var patharray, pobj, patharray;
	patharray = GuruLabs.preparePathArray(gobject_path);
	pobj = gobject;
	for (var i=0; i < patharray.length; i++) {
		if ((_.isObject(pobj)) && (_.has(pobj, patharray[i]))) {
			pobj = pobj[patharray[i]];
		} else {
			return false
		};
	}
	return true;
}


GuruLabs.getObjectPath = function(gobject, gobject_path) {
	// Return the object property specified by the given object path
	//	@input gobject (object): object for which the path should be retrieved
	//	@input gobject_path (str in dot notation): Property to retrieve
	try { 
		return _.chain(GuruLabs.preparePathArray(gobject_path)).reduce(function(obj, key){ return obj[key]; }, gobject).value();
	} catch(e) {
		if (e instanceof TypeError) return undefined;
		else throw e;
	}
}


GuruLabs.removeNewlines = function(rstring) {
	// Remove new lines from the input string
	// @input rstring: String from which to remove all newline characters
	return rstring.replace(/(\r\n|\n|\r)/gm,"");
}


GuruLabs.str2bool = function(istring) {
	// Convert the input string value to a boolean
	if (_.isBoolean(istring)) return istring;
	return _.contains(GuruLabs._positive, istring.toLowerCase());
}


GuruLabs.str2array = function(istr, options) {
	// Convert a string to an array, remove blank strings
	options = options || {};
	_.defaults(options, { split: ' ' });
	return _.without((istr || '').split(options.split), '')
}


GuruLabs.str2arraybuffer = function(str) {
	// Convert a str to a bytearray
	var buf = new ArrayBuffer(str.length*2);	// 2 bytes for each char
	var bufview = new Uint16Array(buf);
	for (var i=0, strlen=str.length; i<strlen; i++) {
		bufview[i] = str.charCodeAt(i);
	};
	return buf;
}


GuruLabs.bool2str_yes_no = function(bool) {
	// Convert a boolean to a yes or no string value
	if (bool) return 'yes'
	return 'no';
}


GuruLabs.object_date2str = function(attributes, attrnames) {
	// Convert named date JavaScript objects to ISO8601 encoded strings
	// 	@input attributes (object): Object for which date objects should be converted
	//		to ISO8601 encoded strings
	//	@input attrnames (array): Array of attribute names (as strings) to be converted
	attributes = attributes || {};
	attrnames = attrnames || [];
	_.each(attrnames, function(attrname){
		if (_.isDate(attributes[attrname]))
			attributes[attrname] = attributes[attrname].toISOString();
	});
}


GuruLabs.label_dollars = function(val, options) {
	// Format the provided value in US dollars
	options = options || {};
	_.defaults(options, { decimals: 2 });

	return '$'+Number((val || 0).toFixed(options.decimals)).toLocaleString();
}


GuruLabs.object_str2date = function(attributes, attrnames) {
	// Convert named ISO8601 encoded strings to JavaScript date objects
	attributes = attributes || {};
	attrnames = attrnames || [];
	_.each(attrnames, function(attrname){
		if (_.isString(attributes[attrname]))
			attributes[attrname] = new Date(attributes[attrname]);
	});
}


GuruLabs.extend = function(protoProps, staticProps) {
	// Helper function to correctly set up the prototype chain for subclasses.
	// Similar to goog.inherits, but uses a hash of the prototype properties and
	// class properties to be extended.
	// The constructor property for the new subclass is either defined by you, 
	// the "constructor" property in your extend definition, or default to simply
	// call the parent's constructor.
	var parent = this;
	var child;
	if (protoProps && _.has(protoProps, 'constructor')) { 
		child = protoProps.constructor;
	} else { 
		child = function(){ return parent.apply(this, arguments); };
	}
	// Add static properties to the constructor function, if supplied
	_.extend(child, parent, staticProps);
	// Set the prototype chain to inherit from parent, without calling parent's
	// constructor arguments.
	var Surrogate = function() { this.constructor = child; };
	Surrogate.prototype = parent.prototype;
	child.prototype = new Surrogate;
	// Add prototype properties (instance properties) to the subclass, if supplied
	if (protoProps) _.extend(child.prototype, protoProps);
	child.__super__ = parent.prototype;
	return child;
}


GuruLabs.createToken = function(length, options) {
	// 	Helper function to create a random string of a specified length
	//	@option charset (default=ASCII letters, upper and lowercase; numbers; digits):
	//		Characters which shuld be used to generate the token

	options = options || {};
	// Check input length
	if (!length)
		throw new Error('create_token: The length of the token must be an integer');
	// Set default options
	_.defaults(options, {
		charset: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
	});
	var token = '';
	_.each(_.range(0, length), function(){
		token += options.charset.charAt(_.random(0, options.charset.length));
	});
	return token;
}


GuruLabs.qs2object = function(qstr) {
	// Parse a querystring and return an object of the key/value pairs
	var qs = new URLSearchParams(qstr);
	var qobj = {};
	
	_.each(Array.from(qs.entries()), function(i) {
		var k = i[0].replace('[]', '');
		var v = i[1];

		// Add value to an existing key
		if (k in qobj) {

			// Encode value as an array (if not already encoded), add second value, reassign
			var val = _.isArray(qobj[k]) ? qobj[k] : [qobj[k]];
			val.push(v);
			qobj[k] = val;

		} else {

			// Add value to the object
			qobj[k] = v;
		}
	});

	return qobj;
}


GuruLabs.serverResponseErrorJSON = function(jsoncallback) {
	//	Translate a jQuery XMLHttpRequest error callback (with signature [jqxhr, textstatus, errorthrown])
	//	to a function which provides the server response encoded as JSON data (signature [jsonobject])

	//	@input jsoncallback (function): Callback function which should accept a JSON object as input
	if (!_.isFunction(jsoncallback)) throw new Error("serverResponseErrorJSON: jsoncallback must be a function");
	return function(jqxhr, textstatus, errorthrown) {
		jsoncallback(jqxhr.responseJSON || {}, jqxhr, textstatus, errorthrown);
	}
}


GuruLabs.modelCollectionEvents = function(model, collection, options) {
	// 	Trigger model change events on modifications to the collection. By default, it triggers
	//	four named events for the event type on the model. Each event has a slightly different 
	//	signature.

	//	1. '{{ prefix }}:model:{{ event }}', cmodel (cmodel is a collection model which has been modified)
	//	2. '{{ prefix }}:collection:{{ collection_name }}:model:{{ event }}', smodel (cmodel is a collection model
	//		which has been modified)
	//	3. 'change'
	//	4. 'change:{{ prefix }}'
	//	5. 'change:{{ prefix }}:{{ collection_name }}'
	
	//	@input model (Backbone.Model): Model upon which to trigger change events
	//	@input collection (Backbone.Collection): Collection to which the model
	//		should listen for changes
	//	@input options (object): Hash of options for the function

	// 	@option events (array, default=['add', 'remove']): Array of collection event names for which
	//		the model should listen
	//	@option model_event_prefix (str, default='related'): Prefix to use in events
	//	@option collection_name (str, default=None): If defined, an additional event will be registered
	//		will be registered that triggers with the collection name

	if ((!model) || (!collection)) 
		throw new Error('modelCollectionEvents: Please provide a valid model and collection');

	// Default options for function
	options = options || {};
	_.defaults(options, { events: ['add', 'remove'], model_event_prefix: 'related', });	
	
	// Verify that events can iterated over
	if (!_.isArray(options.events)) throw new Error('modelCollectionEvents: Please provide a valid events array');
	
	// Attach collection events to the model
	_.each(options.events, function(ename){
		
		// Register common collection events: '{{ prefix }}:model:{{ event }}'', 'change', 'change:{{ prefix }}'
		model.listenTo(collection, ename, function(cmodel){
			model.trigger(options.model_event_prefix+':model:'+ename, cmodel);
			model.trigger('change');
			model.trigger('change:'+options.model_event_prefix);
		});
		
		// Register collection name events: 
		if (options.collection_name) {
			model.listenTo(collection, ename, function(cmodel){
				model.trigger(
					options.model_event_prefix+':collection:'+options.collection_name+':model:'+ename, cmodel);
				model.trigger('change:'+options.model_event_prefix+':'+options.collection_name);
			});
		}
	});
}


GuruLabs.serverDataExchange = function(options) {
	//	Submit an AJAX request to the server. Wrapper function for jQuery.ajax
	//	@input options (default={}): Option array. serverDataExchange accepts the same
	//		input options as $.ajax. The options hash is filtered to exclude 'success', 'error', 
	//		and 'always' before being passsed to $.ajax, however.

	//	@option url (required): URL to which the request should be sent
	//	@option data (required for POST and PUT requests, default={}): Option array
	//	@option method (str, default='POST'): Method to be used for making the request

	//	@callback success (response): Called after data has been submitted to the server
	//	@callback error (jqxhr, textstatus, errorthrown): Called if there was an error submitting
	//		data to the server
	//	@callback always: Called after all submissions

	options = options || {};
	_.defaults(options, { method: 'POST', contentType: 'application/json; charset=utf-8' });
	if (!options.url) throw new Error('Unable to make request, no URL specified');
	if ((options.method == GuruLabs.api.http.post) || (options.method == GuruLabs.api.http.put)) {
		if (!options.data) throw new Error('Unable to send data to server, no data provided');
	}
	return $.ajax(_.omit(options, 'success', 'error', 'always')).done(function(rdata, textstatus, jqxhr) {
		if (_.isFunction(options.success)) options.success(rdata, textstatus, jqxhr);
	}).fail(function(jqxhr, textstatus, errorthrown){
		if (_.isFunction(options.error)) options.error(jqxhr, textstatus, errorthrown);
	}).always(function(){
		if (_.isFunction(options.always)) options.always();
	});
}


GuruLabs.postJSON = function(options) {
	// 	Submit JSON data to the server. Wrapper function for serverDataExchange, kept for source
	//	API compatability. Delegates to GuruLabs.serverDataExchange.
	
	//	@input options (default={}): Option array

	// 	@option url (required): The URL to which the data should be sent
	//	@option data (required): JSON data to send to the server
	
	//	@callback success (response) : Called after data has been submitted to the server
	//	@callback error(jqxhr, textstatus, errorthrown): Called if there was an 
	//		error submitting data to the server
	//	@callback always: Called after all submissions
	
	options = options || {};
	_.defaults(options, { dataType: 'json' });
	return GuruLabs.serverDataExchange(options);
}


GuruLabs.getJSON = function(options) {
	// Retrieve JSON data from the server. Wrapper function for jQuery.getJSON.
	//	Shares options url with GuruLabs.postJSON (see above).
	//	Shares callbacks success, error, always with GuruLabs.postJSON (see above).

	options = options || {};
	if (!options.url) throw new Error('Unable to retrieve data from server, no URL specified');
	return $.getJSON(options.url, function(rdata, textstatus, jqxhr){
		if (_.isFunction(options.success)) options.success(rdata, textstatus, jqxhr);
	}).fail(function(jqxhr, textstatus, errorthrown){
		if (_.isFunction(options.error)) options.error(jqxhr, textstatus, errorthrown);
	}).always(function(){
		if (_.isFunction(options.always)) options.always();
	});
}


GuruLabs.initWebWorker = function(options) {
	// 	Initialize and retrieve a web worker. The script is retrieved via an XMLHttpRequest.

	//	@input options (object): Options hash
	//	@input url (str, required): URL from which the worker should be retrieved.
	//	@callback ready (function): Function to be invoked after the remote worker script has been
	//		retrieved. Signature:
	//		@input worker (WebWorker): Initialized web worker instance
	options = options || {};
	_.defaults(options, { method: 'get', async: true });
	if (!options.url)
		throw new Error('Unable to retrieve web worker script, invalid URL');
	if (!_.isFunction(options.ready))
		throw new Error('Unable to retrieve web worker script, invalid ready function');

	var oReq = new XMLHttpRequest();
	oReq.addEventListener('load', function() {
		var worker = new Worker(window.URL.createObjectURL(new Blob([this.responseText])));
		options.ready(worker);
	}, oReq);
	oReq.open(options.method, options.url, options.async);
	oReq.send();
}


GuruLabs.titleCase = function(istr) {
	// Convert a string to title case: "A tale of two cities" -> "A Tale of Two Cities"
	//	@input istr (str): String to convert to proper case
	return istr.replace(/\w\S*/g, function(txt){
		return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	});
}


GuruLabs.parseUri = function(str) {
	var	o   = GuruLabs.parseUri.options,
		m   = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
		uri = {},
		i   = 14;

	while (i--) uri[o.key[i]] = m[i] || "";

	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
		if ($1) uri[o.q.name][$1] = $2;
	});

	return uri;
};


GuruLabs.parseUri.options = {
	strictMode: false,
	key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
	q:   {
		name:   "queryKey",
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};


GuruLabs.path = _.extend(GuruLabs.path || {}, {
	join: function(/* path segments */) {
		// Join a set of path segments into a complete path

		// Split the inputs into a list of path commands.
		var parts = [];
		for (var i = 0, l = arguments.length; i < l; i++) {
			parts = parts.concat(arguments[i].split("/"));
		}
		// Interpret the path commands to get the new resolved path.
		var newParts = [];
		for (i = 0, l = parts.length; i < l; i++) {
			var part = parts[i];
			// Remove leading and trailing slashes
			// Also remove "." segments
			if (!part || part === ".") continue;
			// Interpret ".." to pop the last segment
			if (part === "..") newParts.pop();
			// Push new path segments.
			else newParts.push(part);
		}
		// Preserve the initial slash if there was one.
		if (parts[0] === "") newParts.unshift("");
		// Turn back into a single string path.
		return newParts.join("/") || (newParts.length ? "/" : ".");
	}, 
	dirname: function(path) {
		// Retrieve the directory name of a path. Trailing slashes are ignored.
		// Leading slash is preserved.
		return GuruLabs.path.join(path, "..");
	}
});


// Base - Models and Collections

GuruLabs.createTrackedObjectProperty = function(gobject, attrname, options) {
	// 	Create a set of JavaScript getter/setter methods for the object which allow for the value
	// 	to be tracked and signals to be emitted on addition, change, or removal. The signal
	//	name is a combination of the signalname option + ':add', ':change', ':remove'.
	//	All signals are triggered prior to setting the value on the object and have the same signature.
	//	Getter and setters are created by invoking Object.defineProperty.

	//	@input gobject (Backbone.js object: Model, Collection, or View): Backbone.js object
	//		for which the tracked property should be created.
	//	@input attrname (str): Name to be used for the tracked property
	//	@input options (options hash)

	//	@option storage_attr (str, default='_'+attrname): Internal attribute to be used for
	//		storing the object attribute data.
	//	@option signalname (str, default='attr:'+attrname): Signal root name to be triggered
	//		upon addition, change, or removal of the property.

	//	@signal signalname+':add': Invoked on addition of a new value to the property.
	//		The value of the property is determined to be 'new' if it was previously undefined
	//		and then modified to any defined value type. Signature:
	//		@input attr_value: Value for the tracked property

	//	@signal signalname+':change': Invoked on change of the property. Any change in value
	//		such as transition from undefined -> new value or value -> undefined will trigger the signal.
	//		@input attr_value: Value for the tracked property

	//	@signal signalname+':remove': Invoked on removal of the property value.
	//		The value of the property is determiend to 'removed' if it was a previously
	//		defined value and transitions to undefined.
	//		@input attr_value: Value for the tracked property

	options = options || {};
	_.defaults(options, { storage_attr: '_'+attrname, signalname: 'attr:'+attrname });

	Object.defineProperty(gobject, attrname, {
		get: function() { return this[options.storage_attr] },
		set: function(val) {
			// Set the value on the object, trigger appropriate signals.

			var attr_undefined = _.isUndefined(this[options.storage_attr]);
			var val_undefined = _.isUndefined(val);
			var val0 = this[options.storage_attr];
			
			// New property added to the object: transition from undefined -> value
			if (attr_undefined && !val_undefined)
				gobject.trigger(options.signalname+':add', val);

			// Property value changed
			if (val0 != val) 
				gobject.trigger(options.signalname+':change', val);

			// Property value removed from the object: transition from value -> undefined
			if (!attr_undefined && val_undefined)
				gobject.trigger(options.signalname+':remove', val);
			
			// Set value
			this[options.storage_attr] = val;
		},
	});
}


GuruLabs.dataExchangeDefaultOptions = function(options, modelref) {
	// 	Helper method which attaches default option values to a data exchange options object
	//	@input options (object)
	//	@input modelref (Backbone.js model): Model which will be used to send the request
	_.defaults(options, {
		signalname: modelref.dataexchange_signalname,
		signalname_prep: modelref.dataexchange_signalname_prep,
		signalname_success: modelref.dataexchange_signalname_success,
		signalname_error: modelref.dataexchange_signalname_error,
		signalname_always: modelref.dataexchange_signalname_always,
	});
}

GuruLabs.dataExchangeCallbacks = function(eoptions, roptions, modelref) {
	// 	Helper method which compiles and attaches data exchange callbacks
	//	@input eoptions (object): Object hash to be passed to GuruLabs.getJSON or GuruLabs.postJSON
	//	@input roptions (object): Object hash sent to getServerData or serverDataExchange
	//	@input modelref (Backbone.js model): Model to be used for triggering signals.
	_.extend(eoptions, {
		success: function(rdata) {
			modelref.trigger(roptions.signalname+':'+roptions.signalname_success, rdata);
			if (_.isFunction(roptions.success)) roptions.success(rdata);
		},
		error: function(jqxhr, textstatus, errorthrown) {
			modelref.trigger(roptions.signalname+':'+roptions.signalname_error, jqxhr, textstatus, errorthrown);
			if (_.isFunction(roptions.error)) roptions.error(jqxhr, textstatus, errorthrown);
		},
		always: function() {
			modelref.trigger(roptions.signalname+':'+roptions.signalname_always);
			if (_.isFunction(roptions.always)) roptions.always();
		}
	});
}


GuruLabs.forwardSignalsToContainer = function(gobject, container, signals, options) {
	//	Forward view signals to a container. View signals are forwarded by binding a listener
	//	to the signal, which then triggers the same signal (with the same arguments) on the container.
	
	//	@input gobject (Backbone.object): Object from which the signals originate
	//	@input container (Backbone.object): Object to where the signals should be forwarded
	//	@input signals (array): Array of signals which should be forwarded

	//	@option once (bool, default=flase): Toggles how the signal is forwarded to the container.
	//		If false signals are attached permanently (via listenTo). If true, signals are attached
	//		via listenToOnce and will trigger a single time.

	// Verify components
	signals = signals || [];
	options = options || {};
	_.defaults(options, { once: false });
	
	if (!_.isArray(signals))
		throw new Error('forwardViewSignalsToContainer: signals must be an array of the signals to be forwarded');
	
	_.each(signals, function(signalname){

		// Compile forward signals callback
		var signal_forward = function() {
			var args = Array.prototype.slice.call(arguments);
			args.unshift(signalname);
			container.trigger.apply(container, args);
		}

		// Attach
		if (options.once) gobject.listenToOnce(gobject, signalname, signal_forward); 
		else gobject.listenTo(gobject, signalname, signal_forward);
	});
}


GuruLabs.Models.GuruCoreModel = Backbone.Model.extend({
	// 	Core model which serve as the foundation for BaseModel and ApplicationModel.
	//	Child models should inherit from BaseModel or ApplicationModel.

	//	@signal 'dataexchange:success', response: Triggered after a server data exchange
	//		has successfully completed
	//	@signal 'dataexchange:error', jqxhr, textstatus, errorthrown: Triggered if there
	//		was an error during a server data exchange
	//	@signal 'dataexchange:always': Triggered after all server data exchanges

	dataexchange_signalname: 'dataexchange',
	dataexchange_signalname_success: 'success',
	dataexchange_signalname_prep: 'prep',
	dataexchange_signalname_error: 'error',
	dataexchange_signalname_always: 'always',


	getServerData: function(roptions) {
		//	Retrieves JSON encoded data from a server. Useful for retrieving data
		//	from a server that is associated with a model, but not direct attributes.
		//	Wrapper around $.getJSON. Similar to serverDataExchange. Shares common options
		//	url, signalname, signalname_prep, signalname_success, signalname_error, signalname_always
		//	with serverDataExchange method. Also shares callbacks success, error, and always. Please see
		//	the option descriptions below for more information.
		roptions = roptions || {};
		GuruLabs.dataExchangeDefaultOptions(roptions, this);
		var eoptions = _.pick(roptions, 'url');
		GuruLabs.dataExchangeCallbacks(eoptions, roptions, this);
		this.trigger(roptions+':'+roptions.signalname_prep);
		return GuruLabs.getJSON(eoptions);
	},

	serverDataExchange: function(roptions) {
		//	Send a JSON encoded POST request to the server. Useful for exchanging data
		//	with a server that are associated with a model, but not direct attributes.
		//	Delegates to GuruLabs.serverDataExchange.

		//	@option url (str, required): URL to which the data should be sent
		//	@option data (required): JSON to send to the server
		//	@option signalname (default='dataexchange'): Name of the signal to be emitted
		//		by the model during a data exchange. A signal named '{{ signalname }}:{{ signalname_success }} 
		// 		or '{{ signalname }}:{{ signalname_error }}' wil be emitted depending on whether the 
		//		exchange was successful or experienced an error.
		
		//	@option signalname_prep (default='prep'): Name of the status signal to be emitted by the
		//		model prior to beginning a data exchange. The full signal will have the form
		//		'{{ signalname }}:{{ signalname_prep }}'
		//	@option signalname_success (default='success'): Name of the status signal to be emitted
		//		by the model after a successful data exchange. The full signal will have the form
		//		'{{ signalname }}:{{ signalname_success }}'
		//	@option signalname_error (default='error'): Name of the status signal to be emitted 
		//		by the model if there was a problem during the data exchange. The full signal will
		//		have the form '{{ signalname }}:{{ signalname_success }}'
		//	@option signalname_always (default='always'): Name of the status signal to be emitted
		//		by the model after all data exchanges. The full signal will have the form
		//		'{{ signalname }}:{{ signalname_always }}'

		//	@callback success (response): Called after data has been submitted to the server
		//	@callback error (jqxhr, textstatus, errorthrown): Called if there was an error submitting
		//		data to the server
		//	@callback always: Called after all submissions

		roptions = roptions || {};
		_.defaults(roptions, {
			method: 'POST',
			dataType: 'json',
		});
		var bmodel = this;
		GuruLabs.dataExchangeDefaultOptions(roptions, this);
		var eoptions = _.pick(roptions, 'url', 'data', 'method', 'dataType', 'contentType');
		GuruLabs.dataExchangeCallbacks(eoptions, roptions, this);
		this.trigger(roptions.signalname+':'+roptions.signalname_prep);
		return GuruLabs.serverDataExchange(eoptions);
	},

	retire: function() {
		// 	Triggers a 'destroy' event on the model, which can be used to remove it from
		// 	collections and close views WITHOUT modifying the model state on the server.
		this.trigger('destroy', this);
		this.stopListening();
	}

});


GuruLabs.Models.BaseModel = GuruLabs.Models.GuruCoreModel.extend({
	// Base model from which all other Guru Labs models inherit

	// @property related (default={}): JS object which can be used to store named
	// 	collections of objects. When the model's toJSON method is called, all objects
	// 	in the collection 
	// @method override toJSON: Serializes model data to JSON. Includes the IDs
	//	of collections that have been added to "related"

	//	@option json_fields_exclude (array, default=undefined): Array of fields to exclude
	//		when calling the model's toJSON array.
	
	related: undefined,

	json_fields_exclude: undefined,

	initialize: function(attributes, options) {
		options = options || {};
		_.defaults(options, {
			related : {},
			json_fields_exclude: this.json_fields_exclude,
		});
		bmodel = this;

		// Create tracked properties for URLs
		GuruLabs.createTrackedObjectProperty(this, 'createurl', { signalname: 'url:create' });
		GuruLabs.createTrackedObjectProperty(this, 'updateurl', { signalname: 'url:update' });

		// Object URL properties
		this.createurl = options.createurl;
		this.updateurl = options.updateurl;
		this.json_fields_exclude = options.json_fields_exclude;
		
		// Default options
		this.related = {};
		
		// Add related model collections
		_.each(options.related, function(rcollection, rname){
			bmodel.addRelatedCollection(rname, rcollection);
		});
		bmodel.listenTo(bmodel, 'sync', bmodel.serverResponse.bind(bmodel));
	},

	addCollection: function(group_name, cname, collection) {
		// Add a model collection to a named group object
		
		// @input group_name (string): Group to which the named collection should be added.
		//	The model must have a property name which matches the group name, otherwise
		//	an error will be thrown.
		// @input cname (string): Name of the collection to be added to the group
		//	object. Collections are indexed by the collection name.
		// @input collection (Backbone.Collection): Collection object to be added to the group

		var bmodel = this;
		if (!_.has(this, group_name)) throw new Error('addCollection(): The model does not have ' 
			+ 'a "' + group_name + '"" property ');
		if (!_.isObject(this[group_name])) throw new Error('addCollection(): ' + group_name 
			+ ' is not a JavaScript object')
		this[group_name][cname] = collection;
		GuruLabs.modelCollectionEvents(this, collection, {
			model_event_prefix: group_name,
			collection_name: cname,
		});
	},

	removeCollection: function(group_name, cname) {
		// Remove a model collection from a named group object

		//	@input group_name (str): Group from which the named collection should be removed
		//		The model must have a property name which matches the group name, otherwise an error
		//		will be thrown.
		//	@input cname (str): Name of the collection to be added to the group
		//		object. Collections are indexed, by the collection name.
		//	@input collection (Backbone.Collection): Collection to be removed from the group.
		//		The collection object must match the cid of the object registered,or an
		//		error will be thrown.
		var bmodel = this;
		if (!_.has(this, group_name))
			throw new Error('removeCollection: the model does not have a "'+group_name+'" property');
		if (!_.isObject(this[group_name]))
			throw new Error('removeCollection: "'+group_name+'" is not not a JavaScript object');
		if (!this[group_name][cname])
			throw new Error('removeCollection: no collection "'+cname+'" defined in group "'+group_name+'"');

		// Remove model listeners for the bound collection, replace the value with undefined
		this.stopListening(this[group_name][cname]);
		this[group_name][cname] = undefined;
	},

	addRelatedCollection: function(cname, collection) {
		// Add related collection to the model
		// @signal: When new items are added to the collection, two events 
		// 	are triggered: "related:model:add" and 
		// 	"related:collection:{{ collection-name }}:model:add"
		// @signal: When items are removed from the collection, two events
		//	are triggered (similar to when events are added): "related:model:remove"
		//	and "related:collection:{{ collection-name }}:model:remove"
		this.addCollection('related', cname, collection);
	},

	removeRelatedCollection: function(cname) {
		// Remove related collection from the model
		this.removeCollection('related', cname);
	},

	toJSON: function(options) {
		// 	Convert the contents of the model to a JSON structure which can be sent to
		//	the server. For models with related model collections, the array of related models
		// 	will also be serialized and added to the object (indexed to the collection's
		//	name in the related array).
		//	@input options (default={}): Hash of options
		
		//	@option jstypes (default=false): Return raw JavaScript objects for use in 
		//		an Underscore.js microtemplate rather than serialized values.
		//	@option related (default=true): Include related models as part of the toJSON output
		//	@option fields_exclude (array, default=model.json_fields_exclude): Array of fiels
		//		to be omitted from the JSON output
		
		//	@returns JSON object

		options = options || {};
		_.defaults(options, {
			jstypes: false, 
			related: true,
			related_options: {},
			fields_exclude: this.json_fields_exclude,
		});
		var mjson = Backbone.Model.prototype.toJSON.apply(this, [options,]);
		if (options.related) {
			_.each(this.related, function(rcollection, rname){
				mjson[rname] =  rcollection.toJSON(_.extend(
					options.related_options[rname] || {}, _.pick(options, 'jstypes')));
			});
		}
		if (this.isNew()) mjson.cid = this.cid;
		return options.fields_exclude ? _.omit(mjson, options.fields_exclude) : mjson;
	},

	serverResponse: function(model, response, options) {
		// Process a successful server sync
		// Retrieves the model ID, update URL, and other important information
		// if (_.has(response, this.idAttribute || 'id')) model.set(this.idAttribute || 'id', response[this.idAttribute || 'id']);
		if (_.has(response, GuruLabs.api.updateurl)) model.updateurl = response[GuruLabs.api.updateurl]
	},

	parse: function(sresponse, options) {
		// 	Parse a server response (or data object) to a set of model attributes.
		//	Filters out responses that are part of the GuruLabs data exchange API
		//	@input sresponse (object): Server response or attributes hash
		//	@input options (object): Set of model options
		//	@returns JSON object of model attributes
		var attributes = sresponse;
		
		// Filter Guru Labs data exchange API responses
		if ((_.has(sresponse, GuruLabs.api.object_data)) | (_.has(sresponse, GuruLabs.api.opresult)) 
			| (_.has(sresponse, GuruLabs.api.operation))
			| (_.has(sresponse, GuruLabs.api.operations))) {
			attributes = sresponse[GuruLabs.api.object_data] || {};
		}
		return attributes;
	},

	url: function() {
		if (this.isNew()) {
			if (_.isUndefined(this.createurl))
				throw new Error('Unable to provide url, no create url defined for model');
			return this.createurl;
		}
		if (_.isUndefined(this.updateurl))
			throw new Error('Unable to provide url, no update url defined for model');
		return this.updateurl;
	},

	save: function() {
		this.trigger('save:prep');
		GuruLabs.Models.GuruCoreModel.prototype.save.apply(this, arguments);
	},

});


// Collections

GuruLabs.moveCollectionModel = function(collection, model, idx_dest) {
	// 	Move the specified model in the specified collection from the index 
	//	to the destination index

	// 	Retrieve index determine if the model is already at the correct location
	//	in the model index sequence
	var midx = collection.at(model);
	if (midx == idx_dest) return collection;

	// Temporarily remove the model from the collection and then re-add it at the dest
	collection.remove(model);
	collection.add(model, { at: idx_dest });
	return collection;
}


GuruLabs.collectionModelIds = function(collection, options) {
	// Returns a list of all of the model IDs (and optionally CIDs) in the collection

	//	@input collection: Collection for which the IDs should be retrieved
	//	@option include_cid (bool, default=false): When true, client only (CID) model CIDs are included in the list.

	//	@returns list of model IDs (and CIDs if include_cide=true)
	options = options || {};
	_.defaults(options, { include_cid: false });

	return collection.chain().filter(function(model){
			return options.include_cid ? 
				model.id || model.cid !== undefined		// Include all models (ID or CID)
				: model.id != undefined	// Only include models defined with a defined (server-side) ID
		}).map(function(model){
			return options.include_cid ? model.id || model.cid : model.id;
		}).value();
}


GuruLabs.defaultRelatedCollection = function(modelclass, options) {
	options = options || {};
	_.defaults(options, {
		json_output_type: GuruLabs.Collections.output_type_full,
		json_full_changed_models: true,
		collection_class: GuruLabs.Collections.BaseModelCollection,
	});
	return new options.collection_class([], {
		model: modelclass,
		json_output_type: options.json_output_type,
		json_full_changed_models: options.json_full_changed_models,
	});
}


GuruLabs.defaultRelatedPaginatedCollection = function(modelclass, options) {
	options = options || {};
	_.defaults(options, { collection_class: GuruLabs.Collections.PaginatedBaseModelCollection, });
	return GuruLabs.defaultRelatedCollection(modelclass, options);
}


GuruLabs.Collections.output_type_full = 'full';
GuruLabs.Collections.output_type_id = 'id';
GuruLabs.Collections.output_type_id_new = 'id-new';
GuruLabs.Collections.output_type_new = 'new';
GuruLabs.Collections.output_type_id_new_changed = 'id-new-changed';

GuruLabs.Collections.GuruCoreModelCollection = Backbone.Collection.extend({
	//  Collection which serves as the foundation for the BaseModel and ApplicationModel
	//	collections. Child models should inherit from either BaseModel or Application model.

	//	@signal 'clear:prep': Triggered at the beginning of a clear operation, prior to
	//		models being retired.
	//	@signal 'clear:success': Triggered at the end of a clear operation, after all models
	//		in the collection have been retired.

	json_output_type: GuruLabs.Collections.output_type_full,
	json_full_changed_models: false,

	clear: function() {
		// Remove all models from the collection after calling retire
		this.trigger('clear:prep');
		this.each(function(lmodel) {
			if (!_.isUndefined(lmodel)) lmodel.retire();
		});
		if (this.length > 0) this.reset();
		this.trigger('clear:success');
	},

	toJSON: function(options) {
		// Serialize the contents of the collection to JSON

		//	@option output_type (default=collection.json_output_type), valid=['id', 'field:<fieldname>', 'full', 'id-new-changed']
		//		Determines how the contents of the colleciton will be serialized to JSON. Output types:
		//		* 'id': only ID strings will be serialized. 
		//		* 'field:<fieldname>' (example: 'field:name', 'field:''), only the specified field will be included
		//			in the serialized output.  
		//		* 'full': the full contents of the model will be serialized.
		//		* 'new': only include new models into the output
		//		* 'id-new': include the ID strings of existing models and the full JSON output for
		//			new models.
		//		* 'id-new-changed': include the ID strings of models that have not been changed 
		//			(and are defined on the server), and the full JSON output for new or modified models.
		//			Similar to 'id-new' except that JSON output for modified models is also included.
		
		//	@option full (options hash for full model output)
		//		@option changed_models (default=false): Determines which models will be included in the serialized
		//			output. When false, all models are included. When true, only new and changed models
		//			will be included.

		options = options || {};
		_.defaults(options, {
			output_type: this.json_output_type,
			full: { changed_models: this.json_full_changed_models },
		});
		
		// Provide the full JSON output
		if (options.output_type == GuruLabs.Collections.output_type_full) {
			if (options.full.changed_models) {
				// Return only models in the collection that have been changed
				return this.chain().filter(function(model){
					return model.hasChanged() || model.isNew();
				}).map(function(model){ return model.toJSON(options); }).value();
			} else {
				// Return the full collection
				return Backbone.Collection.prototype.toJSON.apply(this, [options,]);
			}
		}
		
		// Only include the IDs of the models in the collection
		else if (options.output_type == GuruLabs.Collections.output_type_id) {
			return GuruLabs.collectionModelIds(this);
		}
		
		// Include full JSON output for new and changed models, ID string for unchanged models
		else if (options.output_type == GuruLabs.Collections.output_type_id_new 
			|| options.output_type == GuruLabs.Collections.output_type_id_new_changed) {
			return this.map(function(model){
				// For new models, return full JSON; when enabled, include full JSON for changed models
				if (model.isNew() 
					|| (options.output_type == GuruLabs.Collections.output_type_id_new_changed && model.hasChanged())) 
					return model.toJSON(options);
				else return model.id;
			});
		}

		// Include FULL JSON output for new models
		else if (options.output_type == GuruLabs.Collections.output_type_new) {
			return this.chain().filter(function(model) {
				return model.isNew();
			}).map(function(model){
				return model.toJSON();
			});
		}
		
		// Only serialize the specified field
		else if (options.output_type.indexOf('field') > -1) {
			var fieldname = options.output_type.split(':')[1];
			return this.chain().map(function(model) {
				return model.get(fieldname);
			}).filter(function(val){ return val != undefined; }).value();
		}
		
		// Invalid JSON serialization type
		else throw new Error('toJSON: Invalid serialization type');
	}
})


GuruLabs.Collections.BaseModelCollection = GuruLabs.Collections.GuruCoreModelCollection.extend({
	// Base collection from which all other Guru Labs collections inherit

	//	@option json_output_type (default='full', valid=['id', 'full']):
	//		Determines how the collections contents will be serialized to JSON

	// 	@property modelname (default=undefined): Name of the collection model,
	//		when added to a model's related object, the modelname is frequently
	// 		used as the key. The modelname can be passed as a parameter in the
	// 		options object

	modelname: undefined,
	model: GuruLabs.Models.BaseModel,
	collectionurl: undefined,

	json_output_type: GuruLabs.Collections.output_type_full,

	initialize: function(initmodels, options) {
		options = options || {};
		_.defaults(options, {
			model : this.model, 
			json_output_type : this.json_output_type,
			json_full_changed_models: this.json_full_changed_models,
		});
		this.model = options.model;
		this.modelname = options.modelname;
		this.collectionurl = options.collectionurl;
		this.json_output_type = options.json_output_type;		// Default toJSON output type
		this.json_full_changed_models = options.json_full_changed_models;
	},

	url: function() { return this.collectionurl },

	fetch: function(options) {
		//	Fetch the default set of models for the collection. Attach success event handler
		//	which scans the response for pagination data (located in the headers) and triggers
		//	pagination events if the headers are present.

		// 	If the page is the first in the collection (where 'page' is equal to 'page-first'),
		//	a 'fetch:paginated:first' signal is triggered. If the page is the last in the collection
		//	where ('page' is equal to 'page-last'), a 'fetch:paginated:last' signal is triggered,
		//	If there are additional pages in the collection (where 'page' is not equal to `page-last`),
		//	a 'fetch:paginated:more' signal will be triggered.
		var pcollection = this;
		pcollection.trigger('fetch:prep');
		var fetchjqxhr = GuruLabs.Collections.GuruCoreModelCollection.prototype.fetch.apply(this, arguments);
		fetchjqxhr.always(function(){ pcollection.trigger('fetch:always'); });
		return fetchjqxhr;
	}
});


GuruLabs.Collections.PaginatedBaseModelCollection = GuruLabs.Collections.BaseModelCollection.extend({
	//	A collection class which can be used to work with paginated sets of server results (which
	//	ahere to the Guru Labs conventions for paginated results). Upon "fetch" of a collection,
	//	the AJAX response headers are checked for pagination data. If pagination data is found in
	//	the response, a set of signals are triggered with copies of the pagination parameters and
	//	data attached.

	//	@signal 'fetch:paginated' collection (Backbone.js Collection), response (response data), pagedata (JSON object):
	//		Signal triggered upon receipt of a response with pagination data included in the headers.
	//		`pagedata` is a JSON object including information about the items included in the response. Example:
	
	//		{
	//			'page': 6,
	//			'page-num-results': 100,
	//			'page-first': 1,
	//			'page-last': 15,
	//			'page-previous': 5,
	//			'page-next': 7,
	//			'result-range-start': 600,
	//			'result-range-stop': 699,
	//			'result-total': 1500,
	//		}

	//	@signal 'fetch:paginated:first': Triggered when there is pagination data in the jQuery response
	//		headers for 'fetch' and the `X-Pagination` header indicates that the results are the first page of data.
	//		(Triggered when 'page' is equal to 'page-first'.)
	//	@signal 'fetch:paginated:more': Triggered when there is pagination data in the jQuery response
	//		headers for 'fetch' and the `X-Pagination` header indicates that there are additional pages of data 
	//		which can be retrieved. (Triggered when 'page' is not equal to 'page-last'.)
	//	@signal 'fetch:paginated:last': Triggered when there is pagination data in the jQuery response
	//		headers for 'fetch' and the `X-Pagination` header indicates that the results are the last page of data.
	//		(Triggered when 'page' is equal to 'page-last'.)

	paginated_fetch_signalname: 'fetch:paginated',

	fetch: function(options) {
		//	Fetch the default set of models for the collection. Attach success event handler
		//	which scans the response for pagination data (located in the headers) and triggers
		//	pagination events if the headers are present.

		// 	If the page is the first in the collection (where 'page' is equal to 'page-first'),
		//	a 'fetch:paginated:first' signal is triggered. If the page is the last in the collection
		//	where ('page' is equal to 'page-last'), a 'fetch:paginated:last' signal is triggered,
		//	If there are additional pages in the collection (where 'page' is not equal to `page-last`),
		//	a 'fetch:paginated:more' signal will be triggered.
		var pcollection = this;
		pcollection.trigger(pcollection.paginated_fetch_signalname+':prep');
		var fetchjqxhr = GuruLabs.Collections.BaseModelCollection.prototype.fetch.apply(this, arguments);
		fetchjqxhr.done(function(data, textstatus, jqxhr) {
			var pagedata = GuruLabs.getPaginationData(jqxhr);
			GuruLabs.parsePaginationData(pcollection, data, pagedata)
		});
		fetchjqxhr.always(function(){ pcollection.trigger(pcollection.paginated_fetch_signalname+':always'); });
		return fetchjqxhr;
	}
});


GuruLabs.getPaginationData = function(jqxhr) {
	var pagedata = null;
	// Check for pagination response header, convert to JSON, trigger signals
	if (jqxhr.getResponseHeader(GuruLabs.api.pagination.header)) {
		// Parse pagination data as JSON object
		if (_.isString(jqxhr.getResponseHeader(GuruLabs.api.pagination.header))) {
			pagedata = JSON.parse(jqxhr.getResponseHeader(GuruLabs.api.pagination.header));
		}
	}
	return pagedata;
}


GuruLabs.parsePaginationData = function(pcollection, data, pagedata, options) {
	options = options || {};
	_.defaults(options, {
		paginated_fetch_signalname: pcollection.paginated_fetch_signalname 
			|| GuruLabs.api.pagination.signalname_default,
	});

	if (pagedata) {

		// Trigger 'fetch:paginated' and 'first', 'more', and 'last' pagination signals
		pcollection.trigger(options.paginated_fetch_signalname, pcollection, data, pagedata);
		if (_.has(pagedata, GuruLabs.api.pagination.page)) {
			var cpagenum = parseInt(pagedata[GuruLabs.api.pagination.page]);
			var totalpagenum = parseInt(pagedata[GuruLabs.api.pagination.page_last] || 0);
			// Check if first page of results
			if (cpagenum == pagedata[GuruLabs.api.pagination.page_first]) pcollection.trigger(options.paginated_fetch_signalname+':first');
			// Check if additional results
			if (cpagenum < totalpagenum) pcollection.trigger(options.paginated_fetch_signalname+':more');
			//	Check if last page of results
			if (cpagenum == totalpagenum) pcollection.trigger(options.paginated_fetch_signalname+':last');
		}
	} else {

		// No pagedata associated with the request
		pcollection.trigger(options.paginated_fetch_signalname+':none', pcollection, data, pagedata);
	}
}


// Application Models and Collections

GuruLabs.Models.ApplicationModel = GuruLabs.Models.GuruCoreModel.extend({
	// Client application models without a representation on the server

	save: function(attributes, options) {
		throw new Error('Application model instances cannot be saved to the server');
	}, 

});

GuruLabs.Collections.ApplicationModelCollection = GuruLabs.Collections.GuruCoreModelCollection.extend({
	// A collection of client models without a represenation on the server

	model: GuruLabs.Models.ApplicationModel,
});


GuruLabs.Models.ManagerBaseModel = GuruLabs.Models.ApplicationModel.extend({
	//	Application base model which can be used to create event management models which are able to help
	//	filter and coordinate with other application models, collections, and views.

	initManagedCollection: function(collection, options) {
		options = options || {};
		_.defaults(options, {
			events: ['add', 'remove', 'change'],
			model_event_prefix: 'collection',
		});
		GuruLabs.modelCollectionEvents(this, collection, options);
		this.listenTo(this, 'destroy', collection.clear.bind(collection));	// Trigger collection reset on model retire
	},

});
